---
author: Bob Dobos, Cathy Seybold, Steve Campbell, Steve Peaslee, Jason Nemecek
title: "Agricultural Organic Soil Subsidence"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: TRUE
        toc_float: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<style>
   tbody tr:nth-child(odd){
    background-color: #F7FBFF;
  }
</style>

Soil health is primarily influenced by human management, which is not captured in soil survey data at this time. These interpretations provide information on inherent soil properties that influence our ability to build healthy soils through management.

## Climate  
Organic soils used in agricultural production are subject to a loss of volume and depth of organic material due to oxidation caused by above normal microbial activity resulting from excessive water drainage, soil disturbance, or extended drought. Microbial mediated oxidation is the primary driver of volume reduction once excess water is removed.   Soil shrinkage and compaction due to dewatering is considered to be secondary. Any drawdown resulting in water levels below soil surface can result in increased subsidence rates.  The subsidence rate can also be influenced by agricultural practices. The type of tillage operation, such as plowing, disc harrowing and switch plowing, moldboard plowing increase the oxidation rate.  The use of no-till practice is recommended to slow the subsidence. Any aggressive tillage measure increases microbiological activity and decreases carbon sequestration.  Drainage water management can be implemented to control water tables to help slow the subsidence rate.

Several soil and site properties influence the rate of organic matter oxidation and subsidence.  Organic soils are generally found in cooler climates, thus, farmed organic soils in warmer climates are vulnerable.  Periodic saturation of the organic soil with water tends to decrease the rate of oxidation since anaerobic decomposition is slower than aerobic decomposition.  The pre-existing degree of decomposition is also a factor in the subsidence rate since as organic matter is decomposed, the remaining material becomes more resistant to decay.  Acidity in soils tends to slow microbial growth so acid soils are less prone to subsidence.  The degree to which each of the soil properties considered promotes oxidation is rated.  The average degree of accelerating microbial oxidation of organic matter is taken as the overall rating.

The ratings are both verbal and numerical. Numerical ratings indicate the suitability of the individual soil properties. The ratings are shown in decimal fractions ranging from 0.01 to 1.00. They indicate gradations between the point at which a soil feature has the most severe propensity for subsidence (1.00) and the point at which the soil has no propensity for subsidence, such as a mineral soil (0.00). 

Rating class terms indicate the rate at which the soils are likely to subside considering all the soil features that are examined for this rating. "Severe subsidence" indicates that the soil has features that are very favorable for the aerobic soil organisms that cause subsidence.  Very careful management will be needed to slow the subsidence rate.  "Moderate subsidence" indicates that the soil has features that are moderately favorable for aerobic soil organisms. The soil can be made more sustainable by careful management.  "Low subsidence" indicates that the soil has one or more features that are unfavorable for aerobic soil organisms.  With careful management the soil can be used for crop production and be nearly sustainable.  Soils that are not organic are rated "Mineral soil".  These soils do not subside due to organic matter oxidation.

The map unit components listed for each map unit in the accompanying Summary by Map Unit table in Web Soil Survey or the Aggregation Report in Soil Data Viewer are determined by the aggregation method chosen. An aggregated rating class is shown for each map unit. The components listed for each map unit are only those that have the same rating class as listed for the map unit. The percent composition of each component in a particular map unit is presented to help the user better understand the percentage of each map unit that has the rating presented. 

Other components with different ratings may be present in each map unit. The ratings for all components, regardless of the map unit aggregated rating, can be viewed by generating the equivalent report from the Soil Reports tab in Web Soil Survey or from the Soil Data Mart site. Onsite investigation may be needed to validate these interpretations and to confirm the identity of the soil on a given site.

## Criteria Table:

Soil or Site Feature|Less limiting|Somewhat limiting|Limiting|Impact
-----------|-----------|-----------|-----------|-----------
Organic layer thickness (cm)|Less than 40|40 to 130|Greater than 130|Thicker organic layer allows more subsidence
Mineral layer thickness (percent)|More than 50|1 to 50|0|Mineral layers retard oxidation
Decay resistance|Highly decomposed plant material, muck|Moderately decomposed plant material, partially decomposed plant material, mucky peat|Undecomposed plant material, slightly decomposed plant material, peat|Humified organic matter is more difficult to oxidize
Frost-free days|Less than 90|90 to 270|Greater than 270|More heat for a longer time favors decomposition
Flooding frequency and duration|"long" duration and "frequent" frequency or "very long" duration"|"long" duration, "rare" or "occasional" frequency"|none|Flooding excludes oxygen
Ponding frequency and duration|"long" duration and "frequent" frequency or "very long" duration"|"long" duration, "rare" or "occasional" frequency"|none|Ponding excludes oxygen
Electrical conductivity (dS/m)|Greater than 8|4 to 8|Less than 4|Saltiness lowers the activity of water
Depth to saturation (cm)|Less than 30|30 to 100|Greater than 100|Saturation excludes oxygen
pH|Less than 3.5 or Greater than 9.5|Between 3.5 and 5.0 or between 7 and 9.5|Between 5.0 and 7.0|There is an optimal pH for microbial activity

## Soil Script breakdown

####  Insert identifier(s) string and WKT geometry for each Area of Interest (AOI) polygon

```{SQL}
CREATE TABLE #AoiTable 
    ( aoiid INT IDENTITY (1,1),
    landunit CHAR(20),
    aoigeom GEOMETRY);
```
 
 * Create AOI table with polygon geometry. Coordinate system must be WGS1984 (EPSG 4326)
 
```{SQL}
SELECT @aoiGeom = GEOMETRY::STGeomFromText('MULTIPOLYGON (((-102.12335160658608 45.959173206572416, -102.13402890980223 45.959218442561564, -102.13386921506947 45.944643788188387, -102.12327175652177 45.944703605814198, -102.12335160658608 45.959173206572416)))', 4326);   
SELECT @aoiGeomFixed = @aoiGeom.MakeValid().STUnion(@aoiGeom.STStartPoint());  
INSERT INTO #AoiTable ( landunit, aoigeom )  
VALUES ('T9981 Fld3', @aoiGeomFixed); 
SELECT @aoiGeom = GEOMETRY::STGeomFromText('MULTIPOLYGON (((-102.1130336443976 45.959162795100383, -102.12335160658608 45.959173206572416, -102.12327175652177 45.944703605814198, -102.1128892282776 45.944710506326032, -102.1130336443976 45.959162795100383)))', 4326);   
SELECT @aoiGeomFixed = @aoiGeom.MakeValid().STUnion(@aoiGeom.STStartPoint());  
INSERT INTO #AoiTable ( landunit, aoigeom )  
VALUES ('T9981 Fld4', @aoiGeomFixed);
```
#### Creates Summary Acres for each landunit

```{SQL}
CREATE TABLE #AoiAcres
    ( aoiid INT,
    landunit CHAR(20),
    landunit_acres FLOAT
    );
```

```{SQL}
INSERT INTO #AoiAcres (aoiid, landunit, landunit_acres )\
SELECT  aoiid, landunit,
SUM( ROUND( ( ( GEOGRAPHY::STGeomFromWKB(aoigeom.STAsBinary(), 4326 ).STArea() ) / 4046.8564224 ), 3 ) ) AS landunit_acres
FROM #AoiTable
GROUP BY aoiid, landunit;
```

|aoiid|	landunit|landunit_acres|
|------|-------------|----------------|
|1|	T9981 Fld3|          	328.952|
|2|	T9981 Fld4  |        	318.722|


#### Populate intersected soil polygon table with geometry
```{SQL}
-- Create intersected soil polygon table with geometry
CREATE TABLE #AoiSoils 
    ( polyid INT IDENTITY (1,1),
    aoiid INT,
    landunit CHAR(20),
    mukey INT,
    soilgeom GEOMETRY
    );
```

```{SQL}
INSERT INTO #AoiSoils (aoiid, landunit, mukey, soilgeom)
SELECT A.aoiid, A.landunit, M.mukey, M.mupolygongeo.STIntersection(A.aoigeom ) AS soilgeom
FROM mupolygon M, #AoiTable A
WHERE mupolygongeo.STIntersects(A.aoigeom) = 1;
```




####  Populates Soil geometry with landunit attribute
```{SQL}
-- Soil geometry with landunits
CREATE TABLE #AoiSoils2 
    ( aoiid INT,
    polyid INT,
    landunit CHAR(20),
    mukey INT,
    poly_acres FLOAT,
    soilgeog GEOGRAPHY
    );
```

```{SQL}
-- Populate Soil geometry with landunit attribute
INSERT INTO #AoiSoils2   
SELECT aoiid, polyid, landunit,  mukey, ROUND((( GEOGRAPHY::STGeomFromWKB(soilgeom.STAsBinary(), 4326 ).STArea() ) / 4046.8564224 ), 3 ) AS poly_acres, GEOGRAPHY::STGeomFromWKB(soilgeom.STAsBinary(), 4326 ) AS soilgeog 
FROM #AoiSoils;
```


#### Populate soil map unit acres, aggregated by mukey (merges polygons together)
```{SQL}
-- Soil map unit acres, aggregated by mukey (merges polygons together)
CREATE TABLE #M2
    ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT
    );
```


```{SQL}
INSERT INTO #M2
SELECT DISTINCT M1.aoiid, M1.landunit, M1.mukey,
ROUND (SUM (M1.poly_acres) OVER(PARTITION BY M1.landunit, M1.mukey), 3) AS mapunit_acres
FROM #AoiSoils2 AS M1
GROUP BY M1.aoiid, M1.landunit, M1.mukey, M1.poly_acres;
```

aoiid|landunit|mukey|mapunit_acres
------|----------|------------|---------------|
1|T9981 Fld3          |354627|0.426
1|T9981 Fld3          |354648|0.287
1|T9981 Fld3          |2494708|1.729
1|T9981 Fld3          |2525720|56.699
1|T9981 Fld3          |2525732|1.35
1|T9981 Fld3          |2525733|0.129
1|T9981 Fld3          |2525739|28.479
1|T9981 Fld3          |2525745|4.983
1|T9981 Fld3          |2525746|16.106
1|T9981 Fld3          |2525754|12.638
1|T9981 Fld3          |2525764|17.691
1|T9981 Fld3          |2525766|0.032
1|T9981 Fld3          |2525769|181.356
1|T9981 Fld3          |2755648|2.449
1|T9981 Fld3          |2755654|4.599
2|T9981 Fld4          |2525720|8.623
2|T9981 Fld4          |2525724|0.458
2|T9981 Fld4          |2525730|31.514
2|T9981 Fld4          |2525745|62.205
2|T9981 Fld4          |2525746|63.55
2|T9981 Fld4          |2525754|23.138
2|T9981 Fld4          |2525767|3.86
2|T9981 Fld4          |2525769|103.909
2|T9981 Fld4          |2755639|0.443
2|T9981 Fld4          |2755643|9.641
2|T9981 Fld4          |2755648|11.382

|aoiid	|landunit|	aoigeom|
|------|-------------|---------------------------------------------------------------------------------------|
|1	|T9981 Fld3	|POLYGON ((-102.13386921506947 45.944643788188387, -102.12327175652177 45.9447036058142, -102.12335160658608 45.959173206572416, -102.13402890980223 45.959218442561564, -102.13386921506947 45.944643788188387))|
|2	|T9981 Fld4|	POLYGON ((-102.12327175652177 45.9447036058142, -102.1128892282776 45.944710506326032, -102.1130336443976 45.959162795100383, -102.12335160658608 45.959173206572416, -102.12327175652177 45.9447036058142))|


### Soil map unit acres, aggregated by mukey (merges polygons together)
```{SQL}
CREATE TABLE #M2
    ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT
    );
```

```{SQL}
INSERT INTO #M2
SELECT DISTINCT M1.aoiid, M1.landunit, M1.mukey,
ROUND (SUM (M1.poly_acres) OVER(PARTITION BY M1.landunit, M1.mukey), 3) AS mapunit_acres
FROM #AoiSoils2 AS M1
GROUP BY M1.aoiid, M1.landunit, M1.mukey, M1.poly_acres;
```

* Populate soil map unit acres, aggregated by mukey (merges polygons together)




###  Component level data with cokey, comppct_r and mapunit sum-of-comppct_r (major components only)
```{SQL}
CREATE TABLE #M4
(   aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    majcompflag CHAR(3),
	mu_pct_sum INT, 
	major_mu_pct_sum INT, 
    drainagecl CHAR(254)
    );

```

```{SQL}
INSERT INTO #M4
SELECT M2.aoiid, M2.landunit, M2.mukey, mapunit_acres, CO.cokey, CO.compname, CO.comppct_r, CO.majcompflag, (SELECT SUM (CCO.comppct_r) 
FROM #M2 AS MM2
INNER JOIN component AS CCO ON CCO.mukey=MM2.mukey  AND M2.mukey=MM2.mukey AND majcompflag = 'Yes'  )  AS  major_mu_pct_sum,

SUM (CO.comppct_r) OVER(PARTITION BY M2.landunit, M2.mukey) AS mu_pct_sum, drainagecl
FROM #M2 AS M2
INNER JOIN component AS CO ON CO.mukey = M2.mukey --AND majcompflag = 'Yes'; --keep major component flag as Yes. It will mess up everything below
```
* Populate component level data with cokey, comppct_r and mapunit sum-of-comppct_r
* #M4 columns: aoiid, landunit, mukey, mapunit_acres, cokey, compname, comppct_r, majcompflag


### Component level ratings for the currently selected soil interpretation
```{SQL}
CREATE TABLE #M5
   ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    rating CHAR(60),
    mu_pct_sum INT
    );
```



 
### Component level ratings with adjusted component percent to account for missing minor components
```{SQL}
CREATE TABLE #M6
   ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    rating CHAR(60),
    mu_pct_sum INT,
    adj_comp_pct FLOAT
    );
```


 
### Component acres by multiplying map unit acres with adjusted component percent
```{SQL}
CREATE TABLE #M8
    ( aoiid INT,
    landunit CHAR(20),
    mukey INT,
    mapunit_acres FLOAT,
    cokey INT,
    compname CHAR(60),
    comppct_r INT,
    rating CHAR(60),
    MU_pct_sum INT,
    adj_comp_pct FLOAT,
    co_acres FLOAT
    );
```


 
### Aggregated rating class values and sum of component acres  by landunit (Tract and Field number)
```{SQL}
CREATE TABLE #M10
    ( landunit CHAR(20),
    rating CHAR(60),
    rating_acres FLOAT
    );
```

### Create a table containing the first six rating classes for each interp

```{SQL}
CREATE TABLE #RatingClasses
(attributename CHAR(60),
ruledesign CHAR(60),
rating1 CHAR(60),
rating2 CHAR(60),
rating3 CHAR(60),
rating4 CHAR(60),
rating5 CHAR(60),
rating6 CHAR(60)
);
```


 
### Create a table containing the first six rating classes for each interp
```{SQL}
CREATE TABLE #RatingDomain
(id INT IDENTITY (1,1),
rating_key CHAR(60),
attributename CHAR(60),
rating CHAR(60),
rating_num INT
);
```



 
### Create table to store survey area datestamps (sacatalog.saverest)
```{SQL}
CREATE TABLE #DateStamps
(landunit CHAR(20),
datestamp VARCHAR(32));
```


```{SQL}
INSERT INTO #DateStamps
SELECT DISTINCT AM.landunit, ([SC].[areasymbol] + ' ' + CONVERT(VARCHAR(32),[SC].[saverest],120) ) AS datestamp
FROM #M4 AM
INNER JOIN mapunit Mu ON AM.mukey = Mu.mukey
INNER JOIN legend LG ON Mu.lkey = LG.lkey
INNER JOIN sacatalog SC ON Lg.areasymbol = SC.areasymbol;
```
* Get survey area dates for all soil mapunits involved 
 
### Create table to store landunit metadata (survey area and saverest) which comes from #DateStamps
```{SQL}
CREATE TABLE #LandunitMetadata
(landunit CHAR(20),
soils_metadata VARCHAR(150)
);
```
```{SQL}
INSERT INTO #LandunitMetadata
SELECT DISTINCT
landunit,
STUFF((SELECT ' | ' + CAST([datestamp] AS VARCHAR(30))
FROM #DateStamps dt2
WHERE dt1.landunit = dt2.landunit
FOR XML PATH ('') ), 1, 2, '') AS soils_metadata
FROM #DateStamps dt1;
```

* Populate landunit soils-metadata

 

### Populate #SDV with interp metadata
```{SQL}
CREATE TABLE #SDV
(attributekey BIGINT,
attributename CHAR(60),
attributetablename CHAR(30),
attributecolumnname CHAR(30),
attributelogicaldatatype CHAR(20),
attributefieldsize SMALLINT,
attributeprecision TINYINT,
attributedescription NVARCHAR(MAX),
attributeuom NVARCHAR(60),
attributeuomabbrev NVARCHAR(30),
attributetype CHAR(20),
nasisrulename CHAR(60),
ruledesign NVARCHAR(60),
notratedphrase CHAR(15),
mapunitlevelattribflag TINYINT,
complevelattribflag TINYINT,
cmonthlevelattribflag TINYINT,
horzlevelattribflag TINYINT,
tiebreakdomainname CHAR(40),
tiebreakruleoptionflag TINYINT,
tiebreaklowlabel CHAR(20),
tiebreakhighlabel CHAR(20),
tiebreakrule SMALLINT,
resultcolumnname CHAR(10),
sqlwhereclause CHAR(255),
primaryconcolname CHAR(30),
pcclogicaldatatype CHAR(20),
primaryconstraintlabel CHAR(30),
secondaryconcolname CHAR(30),
scclogicaldatatype CHAR(20),
secondaryconstraintlabel CHAR(30),
dqmodeoptionflag TINYINT,
depthqualifiermode CHAR(20),
layerdepthtotop FLOAT,
layerdepthtobottom FLOAT,
layerdepthuom CHAR(20),
monthrangeoptionflag TINYINT,
beginningmonth CHAR(9),
endingmonth CHAR(9),
horzaggmeth CHAR(30),
interpnullsaszerooptionflag TINYINT,
interpnullsaszeroflag TINYINT,
nullratingreplacementvalue CHAR(254),
basicmodeflag TINYINT,
maplegendkey SMALLINT,
maplegendclasses TINYINT,
maplegendxml XML,
nasissiteid BIGINT,
wlupdated DATETIME,
algorithmname CHAR(50),
componentpercentcutoff TINYINT,
readytodistribute TINYINT,
effectivelogicaldatatype CHAR(20),
rulekey CHAR(30)
);
```


```{SQL}
INSERT INTO #SDV (attributename, nasisrulename, rulekey, ruledesign, notratedphrase, resultcolumnname, maplegendxml, attributedescription)
SELECT sdv.attributename, sdv.nasisrulename, md.rulekey, md.ruledesign, sdv.notratedphrase, sdv.resultcolumnname, sdv.maplegendxml, sdv.attributedescription
FROM sdvattribute sdv
LEFT OUTER JOIN distinterpmd md ON sdv.nasisrulename = md.rulename
WHERE sdv.attributename IN ('Agricultural Organic Soil Subsidence', 'Soil Susceptibility to Compaction', 'Organic Matter Depletion', 'Surface Salt Concentration', 'Hydric Rating by Map Unit', 'Suitability for Aerobic Soil Organisms', 'Ponding Frequency Class','Flooding Frequency Class',
'Available Water Storage','Depth to Water Table', 'Drainage Class', 'Farmland Classification')
GROUP BY md.rulekey, sdv.attributename, sdv.nasisrulename, sdv.resultcolumnname, md.ruledesign, sdv.notratedphrase, sdv.maplegendxml, sdv.attributedescription;
```

* Begin populating static tables. These are for the base soils data and metadata. No interp data yet.
* Create a table containing neccessary interp data
* Please note that if we instead get ruledesign from sdvattribute, those values change to integer as in 1:limitation, 2:suitability






```{SQL}
SELECT @attributeName = 'Agricultural Organic Soil Subsidence';
SELECT @minPct = 10;
SELECT @minAcres = 10;
```
* Defines the soil interpretion
* Sets the minimun cutoff pecent for a resource concern at 10 percent or 10 acres for a given landunit

### XML Parsing
```{SQL}
SELECT @rating1 = (SELECT maplegendxml FROM #SDV WHERE attributename = @attributeName).value('(/Map_Legend/Legend_Elements/Labels/@value)[1]', 'VARCHAR(100)');
SELECT @rating2 = (SELECT maplegendxml FROM #SDV WHERE attributename = @attributeName).value('(/Map_Legend/Legend_Elements/Labels/@value)[2]', 'VARCHAR(100)');
SELECT @rating3 = (SELECT maplegendxml FROM #SDV WHERE attributename = @attributeName).value('(/Map_Legend/Legend_Elements/Labels/@value)[3]', 'VARCHAR(100)');
SELECT @rating4 = (SELECT maplegendxml FROM #SDV WHERE attributename = @attributeName).value('(/Map_Legend/Legend_Elements/Labels/@value)[4]', 'VARCHAR(100)');
SELECT @rating5 = (SELECT maplegendxml FROM #SDV WHERE attributename = @attributeName).value('(/Map_Legend/Legend_Elements/Labels/@value)[5]', 'VARCHAR(100)');
SELECT @rating6 = (SELECT maplegendxml FROM #SDV WHERE attributename = @attributeName).value('(/Map_Legend/Legend_Elements/Labels/@value)[6]', 'VARCHAR(100)');
```
Get ordered set of interphrc values from sdvattribute.maplegendxml. This is assumed to begin with the 'worst' rating. Need to double-check this for all interps.

### Set interp rulekey and ruledesign as a variable to be used in cointerp query
```{SQL}
SELECT @ruleKey = (SELECT rulekey FROM #SDV WHERE attributename = @attributeName);
SELECT @ruleDesign = (SELECT ruledesign FROM #SDV WHERE attributename = @attributeName)
SELECT @notRatedPhrase = (SELECT notratedphrase FROM #SDV WHERE attributename = @attributeName);
```

###  Add Not rated phrase to @rating variables
```{SQL}
IF @notRatedPhrase IS NOT NULL
  IF @rating1 IS NULL (SELECT @rating1 = @notRatedPhrase)
  ELSE 
    IF @rating2 IS NULL (SELECT @rating2 = @notRatedPhrase)
    ELSE
      IF @rating3 IS NULL (SELECT @rating3 = @notRatedPhrase)
      ELSE
        IF @rating4 IS NULL (SELECT @rating4 = @notRatedPhrase)
        ELSE 
          IF @rating5 IS NULL (SELECT @rating5 = @notRatedPhrase)
          ELSE
            IF @rating6 IS NULL (SELECT @rating6 = @notRatedPhrase)
```


### Append the rating classes for this interp to the #RatingClasses table
```{SQL}
CREATE TABLE #RatingClasses
(attributename CHAR(60),
ruledesign CHAR(60),
rating1 CHAR(60),
rating2 CHAR(60),
rating3 CHAR(60),
rating4 CHAR(60),
rating5 CHAR(60),
rating6 CHAR(60)
);
```



```{SQL }
INSERT INTO #RatingClasses (attributename, ruledesign, rating1, rating2, rating3, rating4, rating5, rating6)
SELECT @attributeName AS attributename, @ruleDesign AS ruledesign, @rating1 AS rating1, @rating2 AS rating2, @rating3 AS rating3, @rating4 AS rating4, @rating5 AS rating5, @rating6 AS rating6;
```

* Create a table containing the first six rating classes for each interp

### Populate the #RatingDomain table with a unique rating_key for this interp

```{SQL}
CREATE TABLE #RatingDomain
(id INT IDENTITY (1,1),
rating_key CHAR(60),
attributename CHAR(60),
rating CHAR(60),
rating_num INT
);
```


```{SQL}
SELECT @ratingKey = RTRIM(@attributeName) + ':1'
IF NOT @rating1 IS NULL INSERT INTO #RatingDomain VALUES( @ratingKey, @attributename, @rating1, 1)
 
SELECT @ratingKey = RTRIM(@attributeName) + ':2'
IF NOT @rating2 IS NULL INSERT INTO #RatingDomain VALUES( @ratingKey, @attributename, @rating2, 2)
 
SELECT @ratingKey = RTRIM(@attributeName) + ':3'
IF NOT @rating3 IS NULL INSERT INTO #RatingDomain VALUES( @ratingKey, @attributename, @rating3, 3)
 
SELECT @ratingKey = RTRIM(@attributeName) + ':4'
IF NOT @rating4 IS NULL INSERT INTO #RatingDomain VALUES( @ratingKey, @attributename, @rating4, 4)
 
SELECT @ratingKey = RTRIM(@attributeName) + ':5'
IF NOT @rating5 IS NULL INSERT INTO #RatingDomain VALUES( @ratingKey, @attributename, @rating5, 5)
 
SELECT @ratingKey = RTRIM(@attributeName) + ':6'
IF NOT @rating6 IS NULL INSERT INTO #RatingDomain VALUES( @ratingKey, @attributename, @rating6, 6)
```

* Create a table containing the first six rating classes for each interp

### Populate component level ratings using the currently set soil interpretation

```{SQL}
TRUNCATE TABLE #M5
INSERT INTO #M5
SELECT M4.aoiid, M4.landunit, M4.mukey, mapunit_acres, M4.cokey, M4.compname, M4.comppct_r, TP.interphrc AS rating, SUM (M4.comppct_r) OVER(PARTITION BY M4.landunit, M4.mukey) AS mu_pct_sum
FROM #M4 AS M4
LEFT OUTER JOIN cointerp AS TP ON M4.cokey = TP.cokey AND rulekey = @ruleKey
WHERE M4.majcompflag = 'yes';
```

### Populate component level ratings with adjusted component percent to account for the un-used minor components
```{SQL}
TRUNCATE TABLE #M6
INSERT INTO #M6
SELECT aoiid, landunit, mukey, mapunit_acres, cokey, compname, comppct_r, rating, mu_pct_sum, (1.0 * comppct_r / mu_pct_sum) AS adj_comp_pct
FROM #M5;
```

### Populates component acres by multiplying map unit acres with adjusted component percent
```{SQL}
TRUNCATE TABLE #M8
INSERT INTO #M8
SELECT  aoiid, landunit, mukey, mapunit_acres, cokey, compname, comppct_r, rating, MU_pct_sum, adj_comp_pct, ROUND ( (adj_comp_pct * mapunit_acres), 4) AS co_acres
FROM #M6;
```

### Aggregates the classes and sums up the component acres  by landunit (Tract and Field number)
```{SQL}
TRUNCATE TABLE #M10
INSERT INTO #M10
SELECT landunit, rating, SUM (co_acres) AS rating_acres
FROM #M8
GROUP BY landunit, rating
ORDER BY landunit, rating_acres DESC;
```

### Group of insert statements to populate the final output tables
```{SQL}
INSERT INTO #LandunitRatingsDetailed1 (aoiid, landunit, attributename, rating, rating_key, rating_num, rating_pct, rating_acres, landunit_acres)
SELECT aoiid, M10.landunit, @attributeName AS attributename, M10.rating, RD.rating_key, RD.rating_num,
ROUND ((rating_acres/ landunit_acres) * 100.0, 2) AS rating_pct, 
ROUND (rating_acres,2) AS rating_acres,
ROUND ( landunit_acres, 2) AS landunit_acres
FROM #M10 M10
LEFT OUTER JOIN #AoiAcres ON #AoiAcres.landunit = M10.landunit
INNER JOIN #RatingDomain RD ON M10.rating = RD.rating
WHERE RD.attributename = @attributeName
GROUP BY aoiid, M10.landunit, M10.rating, rating_key, rating_acres, landunit_acres, rating_num
ORDER BY landunit, attributename, rating_num DESC;
```

* Detailed Landunit Ratings1: rating acres and rating percent by area for each soil-landunit polygon
* These will be summarized to a single set of interp ratings for each landunit. Currently there are 5 interps.

### Determines Dominant Critical 
```{SQL}
INSERT INTO #LandunitRatingsDetailed2 (landunit, attributename, rating, rating_num, rating_key, rating_pct, rating_acres, landunit_acres, rolling_pct, rolling_acres)
SELECT landunit, attributename, rating, rating_num, rating_key, rating_pct, rating_acres, landunit_acres,
  rolling_pct = SUM(rating_pct) OVER
  (
    PARTITION BY landunit
    ORDER BY rating_key ROWS UNBOUNDED PRECEDING
  ),
  rolling_acres = SUM(rating_acres) OVER
  (
    PARTITION BY landunit
    ORDER BY rating_key ROWS UNBOUNDED PRECEDING
  )
  FROM #LandunitRatingsDetailed1
  WHERE attributename = @attributeName
  ORDER BY landunit, attributename;
```

* LandunitRatingsDetailed2 is populated with all information plus rolling_pct and rolling_acres which are using in the landunit summary rating.
* Detailed Landunit Ratings2 table columns: landunit, attributename, rating, rating_key, rating_num, rating_pct, rating_acres, landunit_acres, rolling_pct, rolling_acres 

### Landunit Ratings CART
```{SQL}
INSERT INTO #LandunitRatingsCART (id, landunit, attributename, rating, rating_key, rolling_pct, rolling_acres, landunit_acres)
SELECT ROW_NUMBER() OVER(PARTITION BY landunit ORDER BY rating_key ASC) AS "id",
landunit, attributename, rating, rating_key, rolling_pct, rolling_acres, landunit_acres
FROM #LandunitRatingsDetailed2
WHERE attributename = @attributeName AND (rolling_pct >= @minPct OR rolling_acres >= @minAcres)
```


* Identifies the single, most limiting rating (per landunit) that comprises at least 10% by area or 10 acres.
* This record will have an id value of 1.



##  References:
1. Histosols. (2018, March 01). Retrieved from University of Idaho Soil Taxonomy: https://www.cals.uidaho.edu/soilorders/histosols.htm

2. Histosols Organic Soils. (2018, March 01). Retrieved from Reference Soil Group: http://www.fao.org/docrep/003/Y1899E/y1899e04.htm

3. NRCS, U. (2012, March). eFOTG. Retrieved from Soil Subsidence : https://efotg.sc.egov.usda.gov/references/public/AR/Soil_Quality_Degradation_Subsidence.pdf

4. Procedure to Calculate the Soil Conditioning Index for Histosols. (2018, March 01). Retrieved from SCI Histosols: https://www.nrcs.usda.gov/wps/PA.../download?cid...ext=pdf

5. Snyder, A. L. (2018, March 01). University of FL IFAS Extension. Retrieved from Soil Subsidence in the Evergaldes Agrciultural Area Pub #SL 311: http://edis.ifas.ufl.edu/ss523





